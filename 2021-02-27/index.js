//https://es6.ruanyifeng.com/

/*
es6模块 与 commonJs模块的差异
1、commonJs模块输出的是值的拷贝，es6模块输出的是值的只读引用
    ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。
    等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，
    原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块
    由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错

2、commonJs模块是运行时加载，es6模块是编译时输出接口

3、commonJs的require是同步加载，es6模块的import的是异步加载

编译时加载与运行时加载区别

因为JavaScript是没有编译动作的，这里的"编译时"，我个人倾向于称为"解析时"，相对于"运行时"而言的。
下面这样ES6代码要求foo.js必须存在，因为在”解析时“要立刻读进来接续看看foo.js里面代码格式正确不正确，import不能出现在if/else里。

import foo from './foo.js'

如果是运行时，就可以像下面这样，编译时才不管foo.js存在不存在，只要这段代码格式没问题就好，在运行时才去读foo.js，没有就出错了。

if (someCondition) {
  foo = require('./foo.js');
}
*/

/*

箭头函数与function函数的区别

箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
箭头函数没有arguments,如果要用，可以用 rest 参数代替 (注意在node环境下是有arguments的)
箭头函数不能作为构造函数，不能使用new
箭头函数没有原型，不能继承
箭头函数不能当做Generator函数,不能使用yield关键字

箭头函数导致this总是指向函数定义生效时所在的对象

由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。

第一个场合是定义对象的方法，且该方法内部包括this。
第二个场合是需要动态this的时候，也不应使用箭头函数。
*/


